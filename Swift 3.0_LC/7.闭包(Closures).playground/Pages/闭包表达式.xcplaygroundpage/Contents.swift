//: ## 闭包表达式语法（Closure Expression Syntax）
//: - 闭包表达式语法可以使用(常量)、(变量)和(inout类型)作为参数，不提供默认值。 也可以在参数列表的最后使用可变参数。 元组也可以作为参数和返回值。
//: ---
//: #### `Sorted ` 方法
//: Swift 的标准库提供了一个叫做 `sorted(isOrderedBefore:) `的方法，会根据你提供的排序闭包将已知类型的数组的值进行排序。一旦它排序完成， `sorted(isOrderedBefore:) `方法会返回与原数组类型大小完全相同的一个新数组，该数组的元素是已排序好的。原始数组不会被 `sorted(isOrderedBefore:)` 方法修改。
//下面的闭包表达式示例使用 sorted(isOrderedBefore:) 方法对一个 String 类型的数组进行字母逆序排序
//以下是初始数组值：
let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella"]
// 闭包函数方式

//: 这个例子对一个 `String` 类型的数组进行排序，因此排序闭包需为一个 `(String, String) -> Bool `的类型函数。提供排序闭包的一个方法是写一个符合其类型需求的普通函数，并将它作为 `sorted(isOrderedBefore:) `方法的形式参数传入：
func backwards(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
}
var reversed = names.sorted(isOrderedBefore: backwards)
/*:
 如果第一个字符串 `s1` 大于第二个字符串 `s2`，`backwards(_:_:)` 函数返回 `true`，表示在新的数组中`s1`应该出现在`s2`前面。比谁大”意思是“比较谁排在字母顺序的后面”。这意味着字母 “ B ” 是“大于”字母 “ A” 的，并且字符串 “ Tom” 大于字符串 “ Tim” 。如果按照相反的字母顺序表的话，” Barry” 应该处于 “ Alex”的前面，依次类推。
 
 总之，这样来写本质上只是一个单一表达函数( a > b )是非常啰嗦的。在这个栗子中，我们更倾向于使用闭包表达式在行内写一个简单的闭包。
 */

//: ---
//: #### 闭包表达式语法
//: 闭包表达式语法形式：
//: -  { (参数列表) -> 返回值类型 in
//: -        执行语句
//: -  }
//实例
var divide = {(val1: Int, val2: Int) -> Int in
    return val1 / val2
}
let result = divide(200, 20)
print (result)

//以上程序执行输出结果为：  10


//:闭包的函数整体部分由关键字 in 导入，这个关键字表示闭包的形式参数类型和返回类型定义已经完成，并且闭包的函数体即将开始。
//闭包的函数体特别短以至于能够只用一行来书写：
divide = {(val1: Int, val2: Int) -> Int in return val1 / val2 }
//: ---
//: #### 从语境中推断类型
//: 因排序闭包为实际参数来传递给函数，故 Swift 能推断它的形式参数类型和返回类型。 形式参数是一个 (Int,  Int) -> Int 类型的函数。这意味着 (Int, Int)和 Int 类型不需要被写成闭包表达式定义中的一部分，因为所有的类型都能被推断，返回箭头 ( ->) 和围绕在形式参数名周围的括号也能被省略：
divide = {(val1, val2) in return val1 / val2 }
//:当把闭包作为行内闭包表达式传递给函数，形式参数类型和返回类型都可以被推断出来。所以说，当闭包被用作函数的实际参数时你都不需要用完整格式来书写行内闭包。

//:然而，如果你希望的话仍然可以明确类型，并且在读者阅读你的代码时如果它能避免可能存在的歧义的话还是值得的。在这个 sorted(isOrderedBefore:) 方法的栗子中，闭包的目的很明确，即排序被替换。对读者来说可以放心的假设闭包可能会使用 String 值，因为它正帮一个字符串数组进行排序。

//: ---
//: #### 从单表达式闭包隐式返回

//: - 单表达式闭包能够通过从它们的声明中删掉 return 关键字来隐式返回它们单个表达式的结果，前面的栗子可以写作：
divide = {(val1, val2) in val1 / val2 }
//: - 实际参数的函数类型已经明确必须通过闭包返回一个 Int 值。因为闭包的结构包涵返回 Int 值的单一表达式 (val1 / val2)，因此没有歧义，并且 return 关键字能够被省略。

//: ---
//: #### 简写的实际参数名
//: Swift 自动对行内闭包提供简写实际参数名，你也可以通过 $0 , $1 , $2 等名字来引用闭包的实际参数值。

//: 如果你在闭包表达式中使用这些简写实际参数名，那么你可以在 闭包 的 实际参数列表中 忽略对其的定义，并且简写 实际参数名 的 数字 和类型将会从期望的函数类型中推断出来。 `in` 关键字也能被省略，因为闭包表达式完全由它的函数体组成：

divide = { $0 / $1 }
//这里， $0 和 $1 分别是闭包的第一个和第二个 Int 实际参数。
//: ---
//: #### 运算符函数
//: 实际上还有一种更简短的方式来撰写上述闭包表达式。Swift 的 Int 类型定义了关于大于号（ / ）的特定字符串实现，让其作为一个有两个 Int 类型形式参数的函数并返回一个 Int 类型的值。这正好与  {(val1, val2) in val1 / val2 } 的第二个形式参数需要的函数相匹配。因此，你能简单地传递一个(/)，并且 Swift 将推断你想使用 (/) 特殊字符串函数实现：

divide = (/)


//: [上一页](@previous) | [下一页](@next)
