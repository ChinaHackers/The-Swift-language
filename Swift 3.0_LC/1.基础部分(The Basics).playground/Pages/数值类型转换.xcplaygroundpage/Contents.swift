//: #### 数值类型转换
/*:
通常来讲，即使我们知道代码中的整数变量和常量是非负的，我们也会使用 Int 类型。经常使用默认的整数类型可以确保你的整数常量和变量可以直接被复用并且符合整数字面量的类型推测。

只有在特殊情况下才会使用整数的其他类型，例如需要处理外部长度明确的数据或者为了优化性能、内存占用等其他必要情况。在这些情况下，使用指定长度的类型可以帮助你及时发现意外的值溢出和隐式记录正在使用数据的本质。
*/

//: ---
//: #### 整数转换
//: 不同整数的类型在变量和常量中存储的数字范围是不同的。 
//: - Int8 类型的常量或变量可以存储的数字范围是 -128~127，
//: - UInt8 类型的常量或者变量能存储的数字范围是 0~255 。
//如果数字超出了常量或者变量可存储的范围，编译的时候就会报错：
//let cannotBeNegative: UInt8 = -1        // UInt8 类型不能存储负数，所以会报错
//let tooBig: Int8 = Int8.max + 1         // Int8 类型不能存储超过最大值的数，所以会报错

//: 因为每个数值类型可存储的值的范围不同，你必须根据不同的情况进行数值类型的转换。这种选择性使用的方式可以避免隐式转换的错误并使你代码中的类型转换意图更加清晰。

//: 在下面的例子中，常量 `twoThousand` 的类型是 `UInt16` ，而常量 `one` 的类型是 `UInt8` 。他们不能直接被相加在一起，因为他们的类型不同。所以，这里让 `UInt16 (one ) `创建一个新的 `UInt16` 类型并用 `one` 的值初始化，这样就可以在原来的地方使用了。
let twoThousand: UInt16 = 2_000
let one: UInt8 = 1
let twoThousandAndOne = twoThousand + UInt16(one)

//: 因为加号两边的类型现在都是  UInt16 ，所以现在是可以相加的。输出的常量（ twoThousandAndOne ）被推断为 UInt16 类型，因为他是两个 UInt16 类型的和。

//: - SomeType(ofInitialValue)  是调用 Swift 类型初始化器并传入一个初始值的默认方法。在语言的内部， UInt16 有一个初始化器，可以接受一个 UInt8 类型的值，所以这个初始化器可以用现有的 UInt8来创建一个新的 UInt16 。这里需要注意的是并不能传入任意类型的值，只能传入 UInt16 内部有对应初始化器的值。不过你可以扩展现有的类型来让它可以接收其他类型的值（包括自定义类型）

//: ---
//: - 整数和浮点数转换

//整数和浮点数类型的转换必须显式地指定类型：
let three = 3
let pointOneFourOneFiveNine = 0.14159
let pi = Double(three) + pointOneFourOneFiveNine
// pi 等于 3.14159，所以被推测为 Double 类型
//: - 在这里，常量 `three` 的值被用来创建一个类型为 `Double`的新的值，所以加号两边的值的类型是相同的。没有这个转换，加法就无法进行。
//: - 浮点转换为整数也必须显式地指定类型。一个整数类型可以用一个 `Double` 或者 `Float` 值初始化。
let integerPi = Int(pi)
// integerPi 等于 3，所以被推测为 Int 类型

//: 在用浮点数初始化一个新的整数类型的时候，数值会被删减。也就是说 4.75 会变成 4 ， -3.9 会变为 -3 。

//:> 注意: 结合数字常量和变量的规则与结合数字字面量的规则不同，字面量 3 可以直接和字面量 0.14159 相加，因为数字字面量本身没有明确的类型。它们的类型只有在编译器需要计算的时候才会被推测出来。



//: [Next](@next)
